---
title: 'मल्टी-पेज क्रॉलिंग'
publishedAt: '2025-03-25'
summary: 'इंटरकनेक्टेड वेबसाइटों को क्रॉल करने, साइटमैप का प्रबंधन करने और डुप्लिकेट कंटेंट को संभालने की तकनीकों में महारत हासिल करें'
---

स्टेटिक और डायनामिक दोनों सामग्री स्क्रैपिंग की बुनियादी बातों के साथ, अब एक अधिक व्यापक चुनौती से निपटने का समय है: मल्टी-पेज क्रॉलिंग। यह सेक्शन कई इंटरकनेक्टेड पेजों वाली वेबसाइटों से कुशलतापूर्वक नेवीगेट करने और डेटा निकालने पर केंद्रित है।

मल्टी-पेज वेबसाइटों को क्रॉल करने के दो मुख्य दृष्टिकोण हैं:

1. लिंक-आधारित क्रॉलिंग - पेजों के बीच लिंक का पालन करना
2. साइटमैप-आधारित क्रॉलिंग - sitemap.xml फ़ाइल का उपयोग करना

साइटमैप क्रॉलिंग के लिए, अधिकांश वेबसाइटें एक sitemap.xml फ़ाइल प्रदान करती हैं जो सभी महत्वपूर्ण URLs की सूची बनाती है। इस संरचित XML फ़ाइल में शामिल है:

- पेज URLs
- अंतिम संशोधित तारीखें
- परिवर्तन आवृत्ति
- प्राथमिकता मान

साइटमैप का उपयोग लिंक क्रॉलिंग की तुलना में अधिक कुशल हो सकता है क्योंकि यह:
- पहले से ही पेजों की पूरी सूची प्रदान करता है
- पेज महत्व और ताजगी के बारे में मेटाडेटा शामिल करता है
- अनावश्यक पेजों को क्रॉल करने से बचाता है
- सर्वर लोड को कम करता है

लेकिन इस अध्याय के लिए, हम Crawlee का उपयोग करके मल्टी-पेज ई-कॉमर्स साइट के लिए एक क्रॉलर बनाने पर लिंक-आधारित क्रॉलिंग पर ध्यान केंद्रित करेंगे। Crawlee हमारे लिए वेब क्रॉलिंग की कई जटिलताओं को संभालता है, जिसमें शामिल है:

- स्वचालित queue प्रबंधन और URL deduplication
- अंतर्निहित दर सीमा और retry logic
- कॉन्फ़िगरेबल अनुरोध हैंडलिंग और routing
- डेटा भंडारण और निर्यात

हम जिस साइट संरचना को क्रॉल करेंगे वह इस तरह दिखती है:

```
Homepage
├── श्रेणी: इलेक्ट्रॉनिक्स
│   ├── फोन
│   ├── लैपटॉप
│   └── एक्सेसरीज
├── श्रेणी: कपड़े
│   ├── पुरुषों के
│   └── महिलाओं के
└── फीचर्ड उत्पाद
```

प्रत्येक उत्पाद पेज की श्रेणी के आधार पर अलग-अलग लेआउट हैं, लेकिन हमें सुसंगत जानकारी निकालनी है:

```typescript
// उदाहरण डेटा संरचना जिसे हम बनाना चाहते हैं
interface ProductData {
  name: string;
  price: number;
  rating: { score: number, count: number };
  features: string[];
  status: string; // स्टॉक में, स्टॉक से बाहर, आदि।
}

interface ResultData {
  categories: {
    electronics: {
      phones: ProductData[];
      laptops: ProductData[];
      accessories: ProductData[];
    };
    clothing: {
      mens: {
        shirts: ProductData[];
        pants: ProductData[];
      };
      womens: {
        dresses: ProductData[];
        tops: ProductData[];
      };
    };
  };
  featured_products: FeaturedProduct[];
}
```

### Crawlee के साथ मुख्य क्रॉलिंग अवधारणाएं

1. **Request Queue प्रबंधन**

Crawlee queue को स्वचालित रूप से संभालता है, लेकिन यहां है कि हम इसे कैसे कॉन्फ़िगर करते हैं:

```typescript
import { CheerioCrawler } from 'crawlee';

const crawler = new CheerioCrawler({
    // प्रत्येक अनुरोध को संभालता है
    async requestHandler({ $, request, enqueueLinks }) {
        // पेज को प्रोसेस करें
        const data = extractPageData($);

        // पेज पर मिले नए URLs को स्वचालित रूप से queue करें
        await enqueueLinks({
            selector: 'a',
            baseUrl: request.loadedUrl,
        });
    },
    // समवर्ती अनुरोधों को सीमित करें
    maxConcurrency: 10,
});
```

2. **URL हैंडलिंग**

Crawlee अंतर्निहित URL हैंडलिंग और सामान्यीकरण प्रदान करता है:

```typescript
await crawler.run([startUrl]);

// या अधिक कॉन्फ़िगरेशन के साथ:
await crawler.addRequests([{
    url: startUrl,
    userData: {
        label: 'start',
    },
}]);
```

3. **Route हैंडलिंग**

विभिन्न URLs को विशिष्ट handlers के लिए route करें:

```typescript
const crawler = new CheerioCrawler({
    async requestHandler({ $, request }) {
        const { label } = request.userData;

        switch (label) {
            case 'category':
                return handleCategory($);
            case 'product':
                return handleProduct($);
            default:
                return handleHomepage($);
        }
    },
});
```

4. **डेटा संग्रह**

Crawlee एकत्रित डेटा के लिए अंतर्निहित भंडारण प्रदान करता है:

```typescript
const crawler = new CheerioCrawler({
    async requestHandler({ $, pushData }) {
        const productData = extractProduct($);
        await pushData(productData);
    },
});
```

### वेब क्रॉलिंग सर्वोत्तम प्रथाएं

जबकि Crawlee कई निम्न-स्तरीय चिंताओं को संभालता है, आपको अभी भी विचार करना चाहिए:

1. **कॉन्फ़िगरेशन**
   - उपयुक्त दर सीमा निर्धारित करें
   - retry रणनीतियों को कॉन्फ़िगर करें
   - सार्थक user-agent strings सेट करें

2. **त्रुटि हैंडलिंग**
   - Crawlee की अंतर्निहित त्रुटि हैंडलिंग का उपयोग करें
   - कस्टम त्रुटि callbacks लागू करें
   - सार्थक निदान जानकारी लॉग करें

3. **डेटा संगठन**
   - अपने डेटा को लगातार संरचित करें
   - routing के लिए request labels का उपयोग करें
   - Crawlee की dataset सुविधाओं का लाभ उठाएं

4. **संसाधन प्रबंधन**
   - maxConcurrency को उचित रूप से कॉन्फ़िगर करें
   - आवश्यकता पड़ने पर maxRequestsPerCrawl का उपयोग करें
   - मेमोरी उपयोग की निगरानी करें

### चुनौती

आपका कार्य एक Crawlee-आधारित क्रॉलर बनाना है जो:

1. होमपेज से शुरू होता है और सभी उत्पाद श्रेणियों की खोज करता है
2. प्रत्येक श्रेणी और उप-श्रेणी पेज पर जाता है
3. प्रत्येक सूची से उत्पाद जानकारी निकालता है
4. डेटा को संरचित प्रारूप में व्यवस्थित करता है
5. कई जगह दिखने वाले उत्पादों को संभालता है (जैसे featured और category)

साइट में विभिन्न श्रेणियों में लगभग 25-30 उत्पाद हैं, जिनके अलग-अलग लेआउट और जानकारी संरचनाएं हैं। आपके क्रॉलर को एक व्यापक डेटासेट तैयार करना चाहिए जो श्रेणियों और उत्पादों के बीच पदानुक्रमित संबंध बनाए रखे।

### अपने समाधान का परीक्षण

इनके लिए परीक्षण करें:
- पूर्णता: क्या आपको सभी उत्पाद मिले?
- सटीकता: क्या निकाला गया डेटा सही है?
- संरचना: क्या डेटा ठीक से व्यवस्थित है?
- दक्षता: आपने कितने अनुरोध किए?

`_solved/chapter6/` में हल किया गया उदाहरण Crawlee का उपयोग करके एक संदर्भ कार्यान्वयन प्रदान करता है। कुशल मल्टी-पेज क्रॉलिंग और डेटा संगठन के लिए लाइब्रेरी की सुविधाओं का लाभ उठाने के तरीके को समझने के लिए इसका अध्ययन करें।

खुश क्रॉलिंग!